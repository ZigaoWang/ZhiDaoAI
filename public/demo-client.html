<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>知道 - 学术研究助手</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'PingFang SC', 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1000px;
      margin: 0 auto;
      padding: 20px;
    }
    h1 {
      color: #2c3e50;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    .input-group {
      display: flex;
      gap: 10px;
    }
    input {
      flex: 1;
      padding: 10px;
      font-size: 16px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    button {
      padding: 10px 20px;
      background: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 16px;
    }
    button:hover {
      background: #2980b9;
    }
    button:disabled {
      background: #95a5a6;
      cursor: not-allowed;
    }
    .nav-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 0;
      border-bottom: 1px solid #eee;
      margin-bottom: 20px;
    }
    .nav-title {
      font-size: 24px;
      font-weight: bold;
      color: #2c3e50;
    }
    .nav-links {
      display: flex;
      gap: 20px;
    }
    .nav-link {
      color: #3498db;
      text-decoration: none;
      font-weight: 500;
      padding: 5px 10px;
      border-radius: 4px;
      transition: background-color 0.2s ease;
    }
    .nav-link:hover {
      background-color: #f8f9fa;
      text-decoration: underline;
    }
    .status {
      padding: 15px;
      background: #f8f9fa;
      border-left: 4px solid #3498db;
      margin-bottom: 10px;
    }
    .status.error {
      border-left-color: #e74c3c;
    }
    .status.success {
      border-left-color: #2ecc71;
    }
    .papers-list {
      margin: 10px 0;
      padding: 0;
    }
    .papers-list li {
      padding: 8px;
      background: #f1f1f1;
      margin-bottom: 5px;
      border-radius: 4px;
      list-style-type: none;
    }
    .papers-list li a {
      color: #3498db;
      text-decoration: none;
    }
    .papers-list li a:hover {
      text-decoration: underline;
    }
    .stream-container {
      white-space: pre-wrap;
      font-family: Georgia, 'Times New Roman', Times, serif;
      padding: 15px;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 4px;
      min-height: 200px;
      max-height: 500px;
      overflow-y: auto;
    }
    .progress {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-bottom: 20px;
    }
    .progress-stage {
      padding: 10px;
      background: #ecf0f1;
      border-left: 3px solid #7f8c8d;
      display: flex;
      gap: 10px;
      align-items: center;
    }
    .progress-stage.active {
      background: #d5f5e3;
      border-left-color: #2ecc71;
    }
    .progress-stage.completed {
      background: #e8f8f5;
      border-left-color: #1abc9c;
    }
    .spinner {
      display: inline-block;
      width: 20px;
      height: 20px;
      border: 3px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top-color: #3498db;
      animation: spin 1s ease-in-out infinite;
    }
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    .checkmark {
      display: inline-block;
      width: 20px;
      height: 20px;
      color: #27ae60;
      font-weight: bold;
      text-align: center;
    }
    .citation {
      background-color: #e8f4fc;
      border-radius: 3px;
      padding: 0 3px;
      cursor: pointer;
      transition: background-color 0.2s;
    }
    .citation:hover {
      background-color: #c9e3f8;
    }
    .citation.active {
      background-color: #ffeeba;
    }
    .decision-banner {
      padding: 10px 15px;
      margin: 10px 0;
      border-radius: 4px;
      font-weight: bold;
    }
    
    .direct-answer {
      background-color: #d4edda;
      border-left: 5px solid #28a745;
      color: #155724;
    }
    
    .research-needed {
      background-color: #cce5ff;
      border-left: 5px solid #0d6efd;
      color: #004085;
    }
    
    .search-keyword {
      display: inline-block;
      padding: 4px 8px;
      background: #e9f5ff;
      border: 1px solid #b0d7ff;
      border-radius: 15px;
      font-weight: bold;
      margin: 5px 5px 5px 0;
    }
    
    /* Paper display styles */
    .paper-item {
      margin-bottom: 15px;
      border: 1px solid #ddd;
      border-radius: 5px;
      overflow: hidden;
    }
    
    .paper-header {
      padding: 10px 15px;
      background-color: #f5f5f5;
      cursor: pointer;
      position: relative;
      transition: background-color 0.2s;
    }
    
    .paper-header:hover {
      background-color: #eee;
    }
    
    .paper-header::after {
      content: '▼';
      position: absolute;
      right: 15px;
      transition: transform 0.3s;
    }
    
    .paper-header.expanded::after {
      transform: rotate(180deg);
    }
    
    .paper-details {
      padding: 15px;
      display: none;
    }
    
    .paper-details.expanded {
      display: block;
    }
    
    .paper-title {
      font-weight: bold;
      margin-right: 25px;
    }
    
    .paper-meta {
      font-size: 0.9em;
      color: #666;
      margin-top: 5px;
    }
    
    .paper-source {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 10px;
      font-size: 0.85em;
      margin-right: 8px;
    }
    
    .source-semantic {
      background-color: #e1f5fe;
      color: #0277bd;
    }
    
    .source-core {
      background-color: #e8f5e9;
      color: #2e7d32;
    }
    
    .paper-abstract {
      margin: 10px 0;
      font-style: italic;
      color: #555;
    }
    
    .paper-link {
      display: block;
      margin-top: 10px;
    }
    
    .paper-item.flash {
      animation: highlight 1.5s;
    }
    
    @keyframes highlight {
      0% { background-color: #fff9c4; }
      100% { background-color: transparent; }
    }
    
    .process-steps {
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
      margin: 10px 0;
    }
    
    .process-steps ul {
      margin: 5px 0;
      padding-left: 25px;
    }
    
    /* Citation mappings display */
    .citation-mappings {
      margin-top: 15px;
      padding: 10px;
      background-color: #f9f9f9;
      border-radius: 5px;
    }
    
    .citation-mappings h4 {
      margin-top: 0;
      margin-bottom: 10px;
    }
    
    .citation-mappings ul {
      padding-left: 20px;
      margin: 0;
    }
    
    /* UI enhancements */
    .toggle-view {
      cursor: pointer;
      color: #3498db;
      text-decoration: underline;
    }
    
    .toggle-container {
      margin: 10px 0;
    }
    
    .section-heading {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .section-heading .toggle-btn {
      font-size: 0.8em;
      color: #3498db;
      cursor: pointer;
    }
    
    /* Progress spinner animation for search stages */
    @keyframes pulse {
      0% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0.4); }
      70% { box-shadow: 0 0 0 10px rgba(52, 152, 219, 0); }
      100% { box-shadow: 0 0 0 0 rgba(52, 152, 219, 0); }
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    /* Loading dots animation for waiting */
    .loading-dots::after {
      content: '...';
      animation: dots 1.5s steps(4, end) infinite;
    }
    
    @keyframes dots {
      0%, 20% { content: '.'; }
      40% { content: '..'; }
      60% { content: '...'; }
      90%, 100% { content: ''; }
    }
    
    /* Semantic Scholar badge */
    .badge-semantic {
      display: inline-block;
      background-color: #1857B6;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 0.8em;
      margin-right: 5px;
    }
    
    /* CORE badge */
    .badge-core {
      display: inline-block;
      background-color: #5a9f58;
      color: white;
      padding: 2px 5px;
      border-radius: 3px;
      font-size: 0.8em;
      margin-right: 5px;
    }
  </style>
  
  <!-- Add Marked.js for markdown rendering -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <div class="nav-bar">
    <div class="nav-title">知道 - 学术研究助手</div>
    <div class="nav-links">
      <a href="index.html" class="nav-link">首页</a>
      <a href="subscription.html" class="nav-link">研究订阅</a>
    </div>
  </div>
  
  <div class="container">
    <div class="input-group">
      <input type="text" id="question-input" placeholder="输入研究问题..." />
      <button id="ask-button">提问</button>
    </div>
    
    <div class="progress" id="progress-container" style="display:none;">
      <div class="progress-stage" data-stage="evaluation" id="stage-evaluation">
        <div class="spinner"></div>
        <span>正在评估问题范围...</span>
      </div>
      <div class="progress-stage" data-stage="paper_retrieval" id="stage-paper_retrieval">
        <div class="spinner"></div>
        <span>正在搜索相关论文...</span>
      </div>
      <div class="progress-stage" data-stage="paper_analysis" id="stage-paper_analysis">
        <div class="spinner"></div>
        <span>正在分析论文内容...</span>
      </div>
      <div class="progress-stage" data-stage="answer_generation" id="stage-answer_generation">
        <div class="spinner"></div>
        <span>正在生成回答...</span>
      </div>
    </div>
    
    <div id="papers-container" style="display:none;">
      <h3>相关论文</h3>
      <ul class="papers-list" id="papers-list"></ul>
    </div>
    
    <div id="status-container" style="display:none;" class="status">
      <p id="status-message">正在连接服务器...</p>
    </div>
    
    <div id="answer-container" style="display:none;">
      <h3>研究回答</h3>
      <div class="stream-container" id="answer-content"></div>
      <div class="live-markdown-container" id="live-markdown"></div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', function() {
      // Check if running from file protocol
      if (window.location.protocol === 'file:') {
        // Create error message
        const errorBox = document.createElement('div');
        errorBox.className = 'status error';
        errorBox.innerHTML = `
          <h3>⚠️ 访问方式错误</h3>
          <p>您正在直接从文件系统打开此文件，由于浏览器安全限制，这种方式无法正常工作。</p>
          <p><strong>正确使用方法：</strong></p>
          <ol>
            <li>确保您的Node.js服务器正在运行: <code>node server.js</code></li>
            <li>通过以下地址访问应用: <code>http://localhost:3000/</code></li>
          </ol>
        `;
        
        // Insert at the top of the container
        document.querySelector('.container').prepend(errorBox);
        
        // Disable the button
        document.getElementById('ask-button').disabled = true;
        return;
      }
      
      const questionInput = document.getElementById('question-input');
      const askButton = document.getElementById('ask-button');
      const statusContainer = document.getElementById('status-container');
      const statusMessage = document.getElementById('status-message');
      const answerContainer = document.getElementById('answer-container');
      const answerContent = document.getElementById('answer-content');
      const liveMarkdown = document.getElementById('live-markdown');
      const progressContainer = document.getElementById('progress-container');
      const papersContainer = document.getElementById('papers-container');
      const papersList = document.getElementById('papers-list');
      
      let eventSource = null;
      let decisionBanner = null; // Reference to decision banner
      let citationMapping = {}; // Store citation mappings
      let paperElements = {}; // Store references to paper elements
      let accumulatedText = ''; // Store accumulated text for real-time rendering
      
      // Configure markdown parser
      marked.setOptions({
        breaks: true,
        gfm: true
      });
      
      function updateStage(stageName, isActive) {
        const stageElement = document.getElementById(`stage-${stageName}`);
        if (stageElement) {
          if (isActive) {
            stageElement.classList.add('active');
            stageElement.querySelector('.spinner').style.display = 'inline-block';
          } else {
            stageElement.classList.remove('active');
            stageElement.classList.add('completed');
            stageElement.querySelector('.spinner').style.display = 'none';
            
            // Remove existing checkmark if any
            const existingCheckmark = stageElement.querySelector('.checkmark');
            if (existingCheckmark) existingCheckmark.remove();
            
            // Add checkmark
            const checkmark = document.createElement('div');
            checkmark.className = 'checkmark';
            checkmark.innerHTML = '✓';
            stageElement.prepend(checkmark);
          }
        }
      }
      
      function setStatus(message, type = 'info') {
        statusContainer.style.display = 'block';
        statusContainer.className = `status ${type}`;
        statusMessage.textContent = message;
      }
      
      function togglePaperDetails(header) {
        const details = header.nextElementSibling;
        const isExpanded = details.classList.toggle('expanded');
        header.classList.toggle('expanded', isExpanded);
      }
      
      function highlightCitation(citationKey) {
        // Remove active class from all citations
        document.querySelectorAll('.citation.active').forEach(el => {
          el.classList.remove('active');
        });
        
        // Add active class to clicked citation
        document.querySelectorAll(`.citation[data-key="${citationKey}"]`).forEach(el => {
          el.classList.add('active');
        });
        
        // Scroll to corresponding paper if it exists
        const paperElement = paperElements[citationKey];
        if (paperElement) {
          // Ensure papers section is visible
          papersContainer.style.display = 'block';
          
          // Smooth scroll to the paper
          paperElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
          
          // Flash effect on the paper
          paperElement.classList.remove('flash');
          void paperElement.offsetWidth; // Trigger reflow
          paperElement.classList.add('flash');
          
          // Make sure details are expanded
          const header = paperElement.querySelector('.paper-header');
          const details = paperElement.querySelector('.paper-details');
          if (!details.classList.contains('expanded')) {
            togglePaperDetails(header);
          }
        }
      }
      
      function startStreaming(question) {
        // Reset UI
        answerContent.textContent = '';
        liveMarkdown.innerHTML = '';
        papersList.innerHTML = '';
        answerContainer.style.display = 'none';
        papersContainer.style.display = 'none';
        
        // Reset tracking objects
        citationMapping = {};
        paperElements = {};
        accumulatedText = '';
        
        // Remove any existing decision banner
        if (decisionBanner) {
          decisionBanner.remove();
          decisionBanner = null;
        }
        
        // Show progress tracker
        progressContainer.style.display = 'flex';
        document.querySelectorAll('.progress-stage').forEach(stage => {
          stage.classList.remove('active', 'completed');
          const spinner = stage.querySelector('.spinner');
          if (spinner) spinner.style.display = 'none';
          const checkmark = stage.querySelector('.checkmark');
          if (checkmark) checkmark.remove();
        });
        
        // Disable button during process
        askButton.disabled = true;
        
        // Close any existing connection
        if (eventSource) {
          eventSource.close();
        }
        
        // Connect to SSE endpoint
        const encodedQuestion = encodeURIComponent(question);
        eventSource = new EventSource(`/stream-question?query=${encodedQuestion}`);
        
        setStatus('连接到服务器，正在处理您的问题...');
        
        // Handle different event types from the server
        eventSource.onmessage = function(event) {
          try {
            const data = JSON.parse(event.data);
            
            switch (data.status) {
              case 'connected':
                setStatus('连接建立，正在等待响应...');
                break;
                
              case 'stage_update':
                setStatus(data.message);
                updateStage(data.stage, true);
                break;
                
              case 'papers_finding':
                // Display initial papers as they're being found
                papersContainer.style.display = 'block';
                
                // If this is the first batch, clear the list
                if (papersList.innerHTML === '') {
                  papersList.innerHTML = '';
                }
                
                // Display the papers we have so far
                data.papers.forEach((paper, index) => {
                  displayPaper(paper, index);
                });
                
                setStatus('正在找到和处理论文...');
                break;
                
              case 'substage_update':
                if (data.stage === 'evaluation_complete') {
                  // Mark evaluation stage as complete
                  updateStage('evaluation', false);
                  
                  // Create a decision banner
                  decisionBanner = document.createElement('div');
                  decisionBanner.className = `decision-banner ${data.canAnswer ? 'direct-answer' : 'research-needed'}`;
                  decisionBanner.innerHTML = data.canAnswer ? 
                    '<span>✓ 该问题可以直接从我的知识中回答</span>' :
                    '<span>🔍 需要研究：正在搜索外部来源以获取信息</span>';
                  
                  // Insert after progress container
                  progressContainer.after(decisionBanner);
                  
                  setStatus(data.message);
                }
                else if (data.stage === 'search_term_selected' && data.queryWord) {
                  // Display search keyword
                  if (!decisionBanner) {
                    decisionBanner = document.createElement('div');
                    decisionBanner.className = 'decision-banner research-needed';
                    progressContainer.after(decisionBanner);
                  }
                  
                  const keywordElem = document.createElement('div');
                  keywordElem.innerHTML = `
                    <div>搜索关键词：<span class="search-keyword">${data.queryWord}</span></div>
                  `;
                  decisionBanner.appendChild(keywordElem);
                  
                  setStatus(`正在使用搜索词："${data.queryWord}"`);
                }
                else if (data.stage === 'papers_found') {
                  // Display found papers with collapsible details
                  papersContainer.style.display = 'block';
                  papersList.innerHTML = '';
                  
                  data.papers.forEach((paper, index) => {
                    displayPaper(paper, index);
                  });
                  
                  setStatus(`找到 ${data.papers.length} 个相关论文。`);
                } else if (data.stage === 'filtering_papers') {
                  setStatus(`正在评估论文的相关性...`, 'info');
                } else if (data.stage === 'papers_selected') {
                  // Update display to indicate which papers were selected
                  setStatus(`选中了 ${data.selectedPapers.length} 个最相关的论文进行分析。`, 'success');
                  
                  // Mark selected papers in the UI
                  data.selectedPapers.forEach(selected => {
                    // Find the paper element by title
                    document.querySelectorAll('.paper-item').forEach(item => {
                      const titleElem = item.querySelector('h4');
                      if (titleElem && titleElem.textContent.includes(selected.title)) {
                        // Mark as selected
                        item.classList.add('selected');
                        const tagElem = item.querySelector('.paper-tag');
                        if (tagElem) {
                          tagElem.textContent = '选中';
                          tagElem.classList.add('selected');
                        }
                      }
                    });
                  });
                }
                else {
                  setStatus(data.message);
                }
                break;
              
              case 'streaming':
                // New streaming phase started
                answerContainer.style.display = 'block';
                if (data.stage === 'analyzing_papers') {
                  updateStage('paper_retrieval', false); // Complete previous stage
                  updateStage('paper_analysis', true); // Start current stage
                } else if (data.stage === 'generating_answer') {
                  updateStage('paper_analysis', false); // Complete previous stage
                  updateStage('answer_generation', true); // Start current stage
                }
                break;
                
              case 'token':
                // Individual token from streaming response
                // If this is the first token, make sure container is displayed
                if (!answerContent.textContent) {
                  answerContainer.style.display = 'block';
                }
                
                // Add token to display
                answerContent.textContent += data.token;
                accumulatedText += data.token;
                
                // Update markdown rendering in real-time
                updateMarkdown(accumulatedText);
                
                // Auto-scroll to bottom of rendered content
                liveMarkdown.scrollTop = liveMarkdown.scrollHeight;
                break;
                
              case 'chunk_complete':
                // A chunk of streaming is complete
                if (data.stage === 'generating_answer') {
                  updateStage('answer_generation', false);
                  setStatus('响应完成。', 'success');
                }
                break;
                
              case 'error':
                setStatus(`错误：${data.error}`, 'error');
                eventSource.close();
                askButton.disabled = false;
                break;
                
              case 'complete':
                // Process complete, clean up
                setStatus('响应完成', 'success');
                eventSource.close();
                askButton.disabled = false;
                
                // Store citation mapping if available
                if (data.result && data.result.citationMapping) {
                  citationMapping = data.result.citationMapping.reduce((acc, item) => {
                    acc[item.key] = item;
                    return acc;
                  }, {});
                  
                  // Mark which papers were cited
                  Object.keys(paperElements).forEach(key => {
                    const paperElement = paperElements[key];
                    const tagElement = paperElement.querySelector('.paper-tag');
                    
                    if (citationMapping[key]) {
                      paperElement.classList.add('cited');
                      paperElement.classList.remove('unused');
                      if (tagElement) {
                        tagElement.textContent = '引用';
                        tagElement.classList.remove('unused');
                        tagElement.classList.add('cited');
                      }
                    } else {
                      paperElement.classList.add('unused');
                      if (tagElement) {
                        tagElement.textContent = '未引用';
                        tagElement.classList.remove('cited');
                        tagElement.classList.add('unused');
                      }
                    }
                  });
                }
                
                // Process response text - convert markdown and make citations interactive
                const processedText = answerContent.textContent;
                
                // Convert markdown to HTML
                let html = marked.parse(processedText);
                
                // Make citations interactive
                html = html.replace(/\[([A-Za-z]+\d{4})\]/g, (match, key) => {
                  const citationKey = key;
                  const isCited = citationMapping[citationKey];
                  if (isCited) {
                    return `<span class="citation" data-key="${citationKey}" onclick="this.dispatchEvent(new CustomEvent('citation-click', {bubbles: true, detail: {key: '${citationKey}'}}))">
                      [${citationKey}]
                    </span>`;
                  } else {
                    return match; // Keep as-is if not in our mapping
                  }
                });
                
                // Set the processed HTML
                answerContent.innerHTML = html;
                
                // Add listener for citation clicks
                answerContent.addEventListener('citation-click', (e) => {
                  highlightCitation(e.detail.key);
                });
                break;
                
              default:
                console.log('Unknown status:', data);
            }
          } catch (error) {
            console.error('Error parsing event data:', error);
            setStatus('错误处理服务器响应', 'error');
          }
        };
        
        eventSource.onerror = function() {
          setStatus('连接错误。正在重新连接...', 'error');
          // The browser will automatically try to reconnect
        };
      }
      
      // Real-time markdown processing function
      function updateMarkdown(text) {
        // Process citations in text
        let htmlWithCitations = text.replace(/\[([A-Za-z]+\d{4})\]/g, (match, key) => {
          const citationKey = key;
          const isCited = citationMapping[citationKey];
          if (isCited) {
            return `<a class="citation" data-key="${citationKey}" onclick="this.dispatchEvent(new CustomEvent('citation-click', {bubbles: true, detail: {key: '${citationKey}'}}))">
              [${citationKey}]
            </a>`;
          } else {
            return `<span class="citation-placeholder">${match}</span>`;
          }
        });
        
        // Convert markdown to HTML
        const html = marked.parse(htmlWithCitations);
        liveMarkdown.innerHTML = html;
        
        // Add click event listeners to citations
        document.querySelectorAll('.citation').forEach(citation => {
          citation.addEventListener('click', function(e) {
            const key = this.getAttribute('data-key');
            highlightCitation(key);
            e.preventDefault();
          });
        });
      }
      
      function displayPaper(paper, index) {
        const paperItem = document.createElement('li');
        paperItem.className = 'paper-item';
        paperItem.dataset.index = index;
        
        // Create citation key from author and year
        let authorLastName = 'Unknown';
        if (typeof paper.authors === 'string') {
          // Handle string format
          const firstAuthor = paper.authors.split(',')[0];
          authorLastName = firstAuthor ? firstAuthor.split(' ').pop() : 'Unknown';
        } else if (Array.isArray(paper.authors) && paper.authors.length > 0) {
          // Handle array format
          const firstAuthor = paper.authors[0];
          if (typeof firstAuthor === 'string') {
            authorLastName = firstAuthor.split(' ').pop();
          } else if (firstAuthor && typeof firstAuthor === 'object' && firstAuthor.name) {
            authorLastName = firstAuthor.name.split(' ').pop();
          }
        }
        const citationKey = `${authorLastName}${paper.year || ''}`;
        paperItem.dataset.citationKey = citationKey;
        
        // Store reference to this paper element
        paperElements[citationKey] = paperItem;
        
        // Create header (always visible)
        const header = document.createElement('div');
        header.className = 'paper-header';
        
        // Determine source badge
        let sourceBadgeClass = '';
        if (paper.source === 'Semantic Scholar') {
          sourceBadgeClass = 'source-semantic';
        } else if (paper.source === 'CORE') {
          sourceBadgeClass = 'source-core';
        }
        
        const sourceBadge = `<span class="source-badge ${sourceBadgeClass}">${paper.source || 'Unknown'}</span>`;
        
        header.innerHTML = `
          <h4>${paper.title} ${sourceBadge} <span class="paper-tag unused">未引用</span></h4>
          <span class="toggle-icon"></span>
        `;
        header.addEventListener('click', () => togglePaperDetails(header));
        
        // Create details (expandable)
        const details = document.createElement('div');
        details.className = 'paper-details';
        
        // Prepare authors list
        let authorsList = 'Unknown';
        if (typeof paper.authors === 'string') {
          authorsList = paper.authors;
        } else if (Array.isArray(paper.authors) && paper.authors.length > 0) {
          authorsList = paper.authors.map(author => {
            if (typeof author === 'string') return author;
            return author && author.name ? author.name : 'Unknown';
          }).join(', ');
        }
        
        details.innerHTML = `
          <div class="meta-info">
            <div class="meta-item">
              <i>👥</i> 作者：${authorsList}
            </div>
            <div class="meta-item">
              <i>📅</i> 年份：${paper.year || 'Unknown'}
            </div>
            <div class="meta-item">
              <i>🔗</i> <a href="${paper.link}" target="_blank">查看论文</a>
            </div>
          </div>
          <div class="abstract">
            <strong>摘要：</strong> ${paper.abstract || '无摘要'}
          </div>
        `;
        
        // Append header and details to paper item
        paperItem.appendChild(header);
        paperItem.appendChild(details);
        papersList.appendChild(paperItem);
      }
      
      // Handle form submission
      askButton.addEventListener('click', function() {
        const question = questionInput.value.trim();
        if (question) {
          startStreaming(question);
        } else {
          setStatus('请输入问题', 'error');
        }
      });
      
      // Allow Enter key to submit
      questionInput.addEventListener('keypress', function(e) {
        if (e.key === 'Enter') {
          askButton.click();
        }
      });
    });
  </script>
</body>
</html>
